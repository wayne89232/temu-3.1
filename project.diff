--- a/Makefile.target
+++ b/Makefile.target
@@ -157,7 +157,6 @@ endif # CONFIG_SOFTMMU
 %/translate.o: QEMU_CFLAGS += $(TRANSLATE_OPT_CFLAGS)
 
 dummy := $(call unnest-vars,,obj-y)
+obj-y += plugin.o
 all-obj-y := $(obj-y)
 
 target-obj-y :=

--- a/configure
+++ b/configure
@@ -721,9 +721,6 @@ EOF
   libs_qga="-lws2_32 -lwinmm -lpowrprof $libs_qga"
 fi
 
+
+vine_path=""
+proj_name=""
 werror=""
 
 for opt do
@@ -980,10 +977,6 @@ for opt do
   ;;
   --disable-pie) pie="no"
   ;;
+  --vine-path=*) vine_path="$optarg"
+  ;;
+  --proj-name=*) proj_name="$optarg"
+  ;;
   --enable-werror) werror="yes"
   ;;
   --disable-werror) werror="no"
@@ -4604,55 +4597,6 @@ echo "VERSION=$qemu_version" >>$config_host_mak
 echo "PKGVERSION=$pkgversion" >>$config_host_mak
 echo "SRC_PATH=$source_path" >> $config_host_mak
 echo "TARGET_DIRS=$target_list" >> $config_host_mak
+
+echo "VINE_PATH=$vine_path" >> $config_host_mak
+echo "PROJECT_NAME=$proj_name" >> $config_host_mak
+
+proj_path="$source_path/$proj_name"
+
+if test -z $proj_name; then
+  echo "Error: You must specify a project name"
+  echo "Example: --proj-name=tracecap"
+  exit 1
+
+elif test "$proj_name" = "sample_plugin"; then
+  echo "#define TEMU_HOME \"$source_path\"" >> $config_host_mak
+  echo "#define PROJECT_HOME \"$proj_path\"" >> $config_host_mak
+  echo "#define TAINT_ENABLED 1" >> $config_host_mak
+  echo "#define DEFINE_INSN_BEGIN" >> $config_host_mak
+  echo "#define DEFINE_BLOCK_BEGIN" >> $config_host_mak
+  echo "#define TAINTCHECK_CLEAR_ZERO" >> $config_host_mak
+  echo "#define PLUGIN_SAMPLE" >> $config_host_mak
+
+elif test "$proj_name" = "tracecap"; then
+  echo "#define TEMU_HOME \"$source_path\"" >> $config_host_mak
+  echo "#define PROJECT_HOME \"$proj_path\"" >> $config_host_mak
+  echo "#define TAINT_ENABLED 1" >> $config_host_mak
+  echo "#define DEFINE_BLOCK_BEGIN" >> $config_host_mak
+  echo "#define DEFINE_INSN_BEGIN" >> $config_host_mak    
+  echo "#define DEFINE_INSN_END" >> $config_host_mak    
+  echo "#define DEFINE_EIP_TAINTED" >> $config_host_mak    
+  echo "#define TAINT_FLAGS 1" >> $config_host_mak    
+  echo "#define PRECISE_EFLAGS" >> $config_host_mak
+  echo "#define PLUGIN_TRACECAP" >> $config_host_mak
+
+elif test "$proj_name" = ""; then
+  echo "#define TEMU_HOME \"$source_path\"" >> $config_host_mak
+  echo "#define PROJECT_HOME \"$proj_path\"" >> $config_host_mak
+  echo "#define TAINT_ENABLED 1" >> $config_host_mak
+  echo "#define DEFINE_BLOCK_BEGIN" >> $config_host_mak
+  echo "#define DEFINE_INSN_BEGIN" >> $config_host_mak    
+  echo "#define DEFINE_INSN_END" >> $config_host_mak    
+  echo "#define DEFINE_EIP_TAINTED" >> $config_host_mak    
+  echo "#define TAINT_FLAGS 1" >> $config_host_mak    
+  echo "#define PRECISE_EFLAGS" >> $config_host_mak
+  echo "#define PLUGIN_TRACECAP" >> $config_host_mak
+ 
+else
+  echo "Error: The specified project is not found" 
+  exit 1
+fi
+
 if [ "$docs" = "yes" ] ; then
   echo "BUILD_DOCS=yes" >> $config_host_mak
 fi
@@ -5172,9 +5116,6 @@ esac
 mkdir -p $target_dir
 echo "# Automatically generated by configure - do not modify" > $config_target_mak
 
+echo "include ../config-host.mak" >> $config_target_mak
+
+
 bflt="no"
 interp_prefix1=`echo "$interp_prefix" | sed "s/%M/$target_name/g"`
 gdb_xml_files=""
@@ -325,17 +268,3 @@ void dma_acct_start(BlockBackend *blk, BlockAcctCookie *cookie,
 {
     block_acct_start(blk_get_stats(blk), cookie, sg->size, type);
 }
+typedef struct diskio_record{
+    uint32_t pid;
+    uint32_t timestamp;
+    uint64_t memory_addr;
+    uint64_t length;
+    char* process;
+    char* operation;
+
+}diskio_record_t;
\ No newline at end of file

--- /dev/null
+++ b/fname2sector_f.c
@@ -1,36 +0,0 @@
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+int fname2sector(char* filename){
+  char buf[30];  
+  FILE *fp;
+
+  // bash ./fname2sector.sh filename
+  char* bash = "bash ../../fname2sector_singl.sh ";  
+  char* file = filename;
+
+  char *s = malloc(strlen(bash)+strlen(file)+1);
+  strcpy(s, bash);
+  strcat(s, file);
+
+  if ((fp = popen(s, "r")) == NULL) {  
+      printf("popen() error!\n");  
+      exit(1);  
+  }   
+  // run the shell script with popen
+  fgets(buf, sizeof buf, fp);
+  // fgets the first sector info
+  //printf("%s", buf);
+  pclose(fp);  
+  free(s);
+  int sector = atoi(buf);
+  return sector; 
+}
+
+int main(int argc, char *argv[]) {  
+
+  int sector = fname2sector(argv[1]);
+  printf("%d\n", sector);
+  return 0;  
+} 
diff --git a/fname2sector_res.c b/fname2sector_res.c
--- /dev/null
+++ b/fname2sector_res.c
@@ -1,90 +0,0 @@
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <tsk/libtsk.h>
+
+typedef struct{
+   TSK_FS_FILE *file;
+   TSK_DADDR_T mft_entry_addr;
+   int curr_mft_idx;
+} NTFS_ADDR_MFT_ENTRY;
+
+static TSK_WALK_RET_ENUM
+cb_get_metadata_addr(TSK_FS_FILE *fs_file, TSK_OFF_T a_off, TSK_DADDR_T
+addr,
+      char *buf, size_t size, TSK_FS_BLOCK_FLAG_ENUM flags, void* ptr)
+{
+   NTFS_ADDR_MFT_ENTRY *addr_mfte = (NTFS_ADDR_MFT_ENTRY*)ptr;
+
+   addr_mfte->curr_mft_idx += 4;  
+
+   if(addr_mfte->file->meta->addr < addr_mfte->curr_mft_idx){
+
+      addr_mfte->mft_entry_addr = addr;
+
+      return TSK_WALK_STOP;
+   }
+   return TSK_WALK_CONT;
+}
+
+int main(int argc, char **argv1)
+{
+    TSK_IMG_INFO *img_info;
+    TSK_TCHAR **argv;
+    TSK_FS_INFO *fs_info;
+    TSK_FS_FILE *fs_file;
+    TSK_DADDR_T *addr;
+    uint8_t attr_check;
+
+#ifdef TSK_WIN32
+    // On Windows, get the wide arguments (mingw doesn't support wmain)
+    argv = CommandLineToArgvW(GetCommandLineW(), &argc);
+#else
+    argv = (TSK_TCHAR **) argv1;
+#endif
+    // open the disk image
+    img_info =
+        tsk_img_open_sing((const TSK_TCHAR *) argv[1],
+        TSK_IMG_TYPE_DETECT, 0);
+    if (img_info == NULL) {
+        fprintf(stderr, "Error opening\n");
+        tsk_error_print(stderr);
+        exit(1);
+    }
+    fs_info =
+        tsk_fs_open_img(img_info, 206848*512, TSK_FS_TYPE_NTFS_DETECT);    
+    if (fs_info == NULL) {
+        fprintf(stderr, "Error opening file system\n");
+        tsk_error_print(stderr);
+        exit(1);
+    }
+
+    fs_file = tsk_fs_file_open(fs_info, NULL, (const char*) argv[2]);
+
+    NTFS_ADDR_MFT_ENTRY addr_mfte;
+
+    TSK_FS_FILE *mft_file;
+    
+    /* Open the $MFT file, which has metadata address 0 */
+    mft_file = tsk_fs_file_open_meta(fs_info, NULL, 0);
+    addr_mfte.file = fs_file;
+    addr_mfte.curr_mft_idx = 0;
+
+    /* Process the $MFT file */
+    if((tsk_fs_file_walk(mft_file, TSK_FS_FILE_WALK_FLAG_NONE,
+                        cb_get_metadata_addr,(void*)&addr_mfte) != 0)){
+        printf("fiwalk != 0\n");
+    }
+
+    printf("%" PRId64 "\n", addr_mfte.mft_entry_addr);
+
+    if(mft_file == NULL){
+         fprintf(stderr, "Error opening file\n");
+         tsk_error_print(stderr);
+         exit(1);
+     }
+    tsk_fs_file_close(fs_file);
+    tsk_fs_close(fs_info);
+    tsk_img_close(img_info);
+    return 0;
+}
\ No newline at end of file
diff --git a/fname2sector_singl.sh b/fname2sector_singl.sh
deleted file mode 100644
index 2b21697..0000000
--- /dev/null
+++ b/fname2sector_singl.sh
@@ -1,19 +0,0 @@
+#!/bin/bash
+# $1 = argv -> filename
+
+entry=$(ifind -n "$1" ../../../win7_test.img -o 206848)
+
+info=$(istat -o 206848 ../../../win7_test.img $entry)
+
+cluster=$(sed -n '/init_size/{n;p}' <<<"$info")
+
+clusters=($cluster)
+
+if [ "${clusters[0]}" == "" ]
+then
+    echo "-1000"
+else
+    let sector="${clusters[0]}*8+206848"
+    echo $sector
+fi
+
--- a/hmp-commands.hx
+++ b/hmp-commands.hx
@@ -1701,47 +1700,6 @@ STEXI
 @item info @var{subcommand}
 @findex info
 Show various information about the system state.
+ETEXI
+
+    {
+        .name       = "plugin_set",
+        .args_type  = "property:s,value:s",
+        .params     = "property value",
+        .help       = "set plugin configuration",
+        .mhandler.cmd = hmp_plugin_set,
+    },
+
+STEXI
+@item plugin_set @var{property} @var{value}
+Set plugin configuration
+ETEXI
+
+    {
+        .name       = "plugin_reset",
+        .args_type  = "property:s",
+        .params     = "property",
+        .help       = "reset plugin configuration",
+        .mhandler.cmd = hmp_plugin_reset,
+    },
+
+STEXI
+@item plugin_reset @var{property}
+Reset plugin configuration
+ETEXI
+
+    {
+        .name       = "plugin_toggle",
+        .args_type  = "property:s",
+        .params     = "property",
+        .help       = "set plugin configuration",
+        .mhandler.cmd = hmp_plugin_toggle,
+    },
+
+STEXI
+@item plugin_toggle @var{property}
+Set plugin configuration
+
+
 
 @table @option
 @item info version
@@ -1823,51 +1781,11 @@ show the memory devices
 @end table
 ETEXI
 
+{
+        .name       = "pslist",
+        .args_type  = "command:s?",
+        .params     = "pslist [command]",
+        .help       = "List the active process in guest Windows.",
+        .mhandler.cmd = hmp_pslist,
+},
+
 STEXI
+@item pslist @var{command}
+@findex pslist
+List the active process in guest Windows.
+
+ETEXI
+{
+        .name       = "getcr3",
+        .args_type  = "command:s?",
+        .params     = "getcr3 [command]",
+        .help       = "List the active process cr3 value.",
+        .mhandler.cmd = hmp_getcr3,
+},
+
+STEXI
+@item getcr3 @var{command}
+@findex getcr3
+List the active process cr3 value.
+
+ETEXI
+{
+        .name       = "pool_files",
+        .args_type  = "command:s?",
+        .params     = "pool_files [command]",
+        .help       = "List the files.",
+        .mhandler.cmd = hmp_pool_files,
+},
+
+STEXI
+@item pool_files @var{command}
+@findex pool_files
+List the active files.
+
-@item info trace-events
-show available trace events and their state
 ETEXI
 
 STEXI
 @end table
 ETEXI
--- a/hw/net/e1000.c
+++ b/hw/net/e1000.c
@@ -36,26 +36,25 @@
 #include "qemu/range.h"
 
 #include "e1000_regs.h"
+#include "plugin.h"
 
 static void
 e1000_link_down(E1000State *s)
 {
@@ -666,7 +603,6 @@ e1000_send_packet(E1000State *s, const uint8_t *buf, int size)
     if (s->phy_reg[PHY_CTRL] & MII_CR_LOOPBACK) {
         nc->info->receive(nc, buf, size);
     } else {
+        plugin->nic_send(buf,size);
         qemu_send_packet(nc, buf, size);
     }
 }
@@ -1159,7 +1095,6 @@ e1000_receive_iov(NetClientState *nc, const struct iovec *iov, int iovcnt)
 static ssize_t
 e1000_receive(NetClientState *nc, const uint8_t *buf, size_t size)
 {
+    plugin->nic_recv(buf,size);
     const struct iovec iov = {
         .iov_base = (uint8_t *)buf,
         .iov_len = size
--- a/monitor.c
+++ b/monitor.c
@@ -21,8 +21,6 @@
  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  * THE SOFTWARE.
  */
+
+#include <stdlib.h>
 #include <dirent.h>
 #include "hw/hw.h"
 #include "monitor/qdev.h"
@@ -76,7 +74,6 @@
 #include "qapi/qmp-event.h"
 #include "qapi-event.h"
 #include "sysemu/block-backend.h"
+#include "static_structs_test.h"
 
 /* for hmp_info_irq/pic */
 #if defined(TARGET_SPARC)
@@ -84,8 +81,6 @@
 #endif
 #include "hw/lm32/lm32_pic.h"
 
+#include "plugin.h"
+
 //#define DEBUG
 //#define DEBUG_COMPLETION
 
@@ -965,23 +960,6 @@ static void hmp_info_help(Monitor *mon, const QDict *qdict)
 {
     help_cmd(mon, "info");
 }
+/*Here we implement our code*/
+static void hmp_plugin_set(Monitor *mon, const QDict *qdict)
+{
+    const char *property = qdict_get_str(qdict, "property");
+    const char *value = qdict_get_str(qdict, "value");
+    plugin->set_plugin(property,value);
+}
+static void hmp_plugin_reset(Monitor *mon, const QDict *qdict)
+{
+    const char *property = qdict_get_str(qdict, "property");
+    plugin->reset_plugin(property);
+}
+static void hmp_plugin_toggle(Monitor *mon, const QDict *qdict)
+{
+    const char *property = qdict_get_str(qdict, "property");
+    plugin->toggle_plugin(property);
+}
 
 CommandInfoList *qmp_query_commands(Error **errp)
 {
@@ -1203,7 +1181,7 @@ static void hmp_watchdog_action(Monitor *mon, const QDict *qdict)
 
 static void monitor_printc(Monitor *mon, int c)
 {
+   monitor_printf(mon, ".");
-    monitor_printf(mon, "'");
     switch(c) {
     case '\'':
         monitor_printf(mon, "\\'");
@@ -1352,541 +1330,6 @@ static void memory_dump(Monitor *mon, int count, int format, int wsize,
     }
 }
 
+/*return the integer for a given addr*/
+static uint64_t my_memory_dump_printd(hwaddr addr)
+{
+    CPUArchState *env;
+    int  len;
+    uint8_t buf[16];
+    uint64_t v;
+    len = 8;
+
+    env = mon_get_cpu();
+    if (cpu_memory_rw_debug(ENV_GET_CPU(env), addr, buf, len, 0) < 0) {
+                return -1;
+    }  
+    v = ldq_p(buf);
+    return v;
+}
+
+/*print the char for a given addr*/
+static void my_memory_dump_printc(Monitor *mon, hwaddr addr)
+{
+    CPUArchState *env;
+    int  i, len;
+    uint8_t buf[16];
+    uint64_t v;
+    len = 16; 
+    i = 0;
+   // char name[16];
+
+    env = mon_get_cpu();
+    cpu_memory_rw_debug(ENV_GET_CPU(env), addr, buf, len, 0);
+    // if (cpu_memory_rw_debug(ENV_GET_CPU(env), addr, buf, len, 0) < 0) {
+    //          monitor_printf(mon, " Cannot get ProcessName.\n");
+    // }
+    while (i < len) {
+              v = ldub_p(buf + i);         
+              if (v >= 32 && v <= 126) { //from space to ~
+                     monitor_printf(mon, "%c", (int) v);       
+                    // snprintf(name[i], 16,"%c",(int)v);
+              }  else{
+                     monitor_printf(mon, " ");       
+              }
+              i ++;
+     }
+    //monitor_printf(mon, " %s\n, name");
+}
+
+/*print the char for a given addr*/
+static void memory_dump_string(Monitor *mon, hwaddr addr, int length)
+{
+    CPUArchState *env;
+    int  i, len;
+    uint8_t buf[1000];
+    uint64_t v;
+    len = length; 
+    i = 0;
+
+    env = mon_get_cpu();
+    cpu_memory_rw_debug(ENV_GET_CPU(env), addr, buf, len, 0);
+    while (i < len) {
+              v = ldub_p(buf + i);         
+              if (v >= 32 && v <= 126) { 
+                     monitor_printf(mon, "%c", (int) v);  
+              }  
+              i ++;
+     }
+}
+static char* get_string(hwaddr addr, int length)
+{
+    CPUArchState *env;
+    int  i, len;
+    uint8_t buf[1000];
+    uint64_t v;
+    len = length; 
+    i = 0;
+    char* fname = malloc(length+10);
+
+    env = mon_get_cpu();
+    cpu_memory_rw_debug(ENV_GET_CPU(env), addr, buf, len, 0);
+    while (i < len) {
+              v = ldub_p(buf + i);         
+              if (v >= 32 && v <= 126) { 
+                     // monitor_printf(mon, "%c", (int) v);
+                     //concat v to string
+                     char a[2];  
+                     a[0] = (int)v;
+                     a[1] = 0;
+                     // printf("%s","i");
+                     strcat(fname, a);
+
+              }  
+              i ++;
+     }
+     // printf("%s\n", fname);
+     return fname;
+}
+
+/*return the hex value for a given addr*/
+uint64_t my_memory_dump(hwaddr addr)
+{ 
+
+    CPUArchState *env;
+    int  len;
+    uint8_t buf[16]; 
+    uint64_t v; 
+    len = 8; 
+    env = mon_get_cpu();
+
+    if (cpu_memory_rw_debug(ENV_GET_CPU(env), addr, buf, len, 0) < 0) {
+                return -1;
+    }else{   
+                v = ldq_p(buf);
+                return v;
+    }
+}
+
+char* f2p_mapping(char* fname){
+
+
+
+    target_ulong start_addr = 0xfffff80003b00000;
+    target_ulong end_addr = 0xfffff80004000000; 
+    target_ulong kdbg_value = 0x000003404742444b;
+
+    while(start_addr < end_addr){
+
+        start_addr += KDBG_offset; 
+
+        if(my_memory_dump(start_addr) == kdbg_value)            
+           break;
+    }
+
+    target_ulong KDBG_addr = start_addr - KDBG_offset;
+
+
+    target_ulong pshead_addr ; 
+    target_ulong eprocess_actproclink_addr; 
+    target_ulong eprocess_next_actproclink_addr ;
+    target_ulong pcb_addr;//eprocess_head_addr = pcb
+    target_ulong imagefilename;
+    target_ulong pid_addr , pid_value ;
+    target_ulong handle_table_addr;
+    target_ulong handle_entry;
+    target_ulong pshead_value; 
+    target_ulong table_code; 
+    //char* process_name;
+
+    if(KDBG_addr + KDBG_offset == 0xfffff80004000000) //if not found
+    {
+        printf("Could not found KDBG address. \n");
+             printf("Could not found KDBG address. \n");
+    }
+    else{           
+         pshead_addr  = KDBG_addr + PsActiveProcessHead;
+         pshead_value = my_memory_dump(pshead_addr); 
+           
+         //first process 
+         eprocess_actproclink_addr = my_memory_dump(pshead_value) ;
+         pcb_addr = eprocess_actproclink_addr - PCB;
+         imagefilename = pcb_addr + ImageFileName;
+         pid_addr = pcb_addr + PID; 
+
+         handle_table_addr = my_memory_dump(pcb_addr + handle_table); 
+
+         while(my_memory_dump(eprocess_actproclink_addr) != pshead_value)
+         {
+                eprocess_next_actproclink_addr = my_memory_dump(eprocess_actproclink_addr) ; 
+                pcb_addr = eprocess_next_actproclink_addr - PCB;
+                imagefilename  = pcb_addr + ImageFileName;
+                pid_addr = pcb_addr + PID; 
+                pid_value = my_memory_dump_printd(pid_addr);
+                handle_table_addr = my_memory_dump(pcb_addr + handle_table);
+                //get the address of entry
+                table_code = my_memory_dump(handle_table_addr);
+                handle_entry = table_code & ~7;
+                if(pid_value ==0)
+                    break; //break for last process
+                
+                if((table_code & 7) == 0){
+                    // level 1 handle table
+                    // win7 x64 -> KERNEL_HANDLE_MASK = 0xFFFFFFFF80000000
+                    int i = 0;
+                    while(i < 256){ //256 entries
+                        target_ulong object_addr = (my_memory_dump(handle_entry)&~0x7)|0x8000000000000000;
+                        target_ulong object_type = object_addr+0x18;
+                        target_ulong object_body = object_addr+0x30;
+                        if((my_memory_dump(object_type)&0xffff) == 0x1c){
+                            // monitor_printf(mon,  "Object_body: 0x" TARGET_FMT_lx " \n" ,object_addr+0x30);
+                            int length = (int)(my_memory_dump(object_body+0x58)&0xff);
+                            
+                            //At 0x58: +0x000 length  / +0x008 buffer
+                            if(length != 0){
+                                char* fname2 = malloc(length+11);
+                                fname2 = get_string(my_memory_dump(object_body+0x60), length);
+                                // return fname2;
+                                if(strstr(fname, fname2)){
+                                    //print imagefilename
+                                    return get_string(imagefilename,8);    
+                                }
+                            }
+                        }
+                        handle_entry += 0x10;
+                        i++;
+                    }
+                    
+                }
+                else if((table_code & 7) == 1){
+                    while(my_memory_dump(handle_entry)!=0){
+                        target_ulong lv2_handle_entry = my_memory_dump(handle_entry);
+                        int j = 0;
+                        while(j < 256){ //256 entries
+                            target_ulong object_addr = (my_memory_dump(lv2_handle_entry)&~0x7)|0x8000000000000000;
+                            target_ulong object_type = object_addr+0x18;
+                            target_ulong object_body = object_addr+0x30;
+                            if((my_memory_dump(object_type)&0xffff) == 0x1c){
+                                // monitor_printf(mon,  "Object_body: 0x" TARGET_FMT_lx " \n" ,object_addr+0x30);
+                                int length = (int)(my_memory_dump(object_body+0x58)&0xff);
+                                
+                                //At 0x58: +0x000 length  / +0x008 buffer
+                                if(length != 0){
+                                    char* fname2 = malloc(length+11);
+                                    fname2 = get_string(my_memory_dump(object_body+0x60), length);     
+
+                                    if(strstr(fname, fname2)){
+                                        //print imagefilename
+                                        return get_string(imagefilename,8);    
+                                    }                
+                                }
+                            }
+                            lv2_handle_entry += 0x10;
+                            j++;
+                        }
+                        handle_entry += 0x8;
+                    }
+                }
+                eprocess_actproclink_addr =  eprocess_next_actproclink_addr ;
+         }
+    }    
+    char* str= malloc(sizeof(char));
+    char char1= 'X';
+    str[0] = char1;
+    return str;
+}
+
+/*find KDBG address between start_addr and end_addr*/
+uint64_t findKDBG(void)
+{ 
+  target_ulong start_addr = 0xfffff80003b00000;
+  target_ulong end_addr = 0xfffff80004000000; 
+  target_ulong kdbg_value = 0x000003404742444b;
+
+   while(start_addr != end_addr){
+           start_addr += KDBG_offset; 
+            if(my_memory_dump(start_addr) == kdbg_value)            
+                   break;
+   }
+    return start_addr - KDBG_offset ;  //if not found,return end_addr
+}
+
+void PSlist(Monitor *mon,hwaddr KDBG_addr)
+{
+    target_ulong pshead_addr ; 
+    target_ulong eprocess_actproclink_addr; 
+    target_ulong eprocess_next_actproclink_addr ;
+    target_ulong pcb_addr;//eprocess_head_addr = pcb
+    target_ulong imagefilename;
+    target_ulong pid_addr , pid_value ;
+    target_ulong ppid_addr , ppid_value ;
+    target_ulong handle_table_addr;
+    target_ulong handle_entry;
+    target_ulong pshead_value; 
+    target_ulong table_code; 
+    int process_num = 1;
+    //char* process_name;
+
+    if(KDBG_addr + KDBG_offset == 0xfffff80004000000) //if not found
+    {
+        monitor_printf(mon,  "Could not found KDBG address. \n");
+             monitor_printf(mon,  "Could not found KDBG address. \n");
+    }else{           
+             pshead_addr  = KDBG_addr + PsActiveProcessHead;
+             pshead_value = my_memory_dump(pshead_addr); 
+               
+             //first process 
+             eprocess_actproclink_addr = my_memory_dump(pshead_value) ; //pshead_value 's value = eprocess_actkink_addr
+             pcb_addr = eprocess_actproclink_addr - PCB;
+             imagefilename = pcb_addr + ImageFileName;
+             //process_name = imagefilename;
+             ppid_addr = pcb_addr + PPID; 
+             ppid_value = my_memory_dump_printd(ppid_addr);
+             pid_addr = pcb_addr + PID; 
+             pid_value = my_memory_dump_printd(pid_addr);
+
+             handle_table_addr = my_memory_dump(pcb_addr + handle_table); 
+
+             monitor_printf(mon, "----------------------------------------------\n");
+             monitor_printf(mon,  "KDBG : 0x"TARGET_FMT_lx "\n" ,KDBG_addr);
+             monitor_printf(mon,  "PsActiveProcessHead : 0x" TARGET_FMT_lx " (value:0x%0*" PRIx64 ")\n" ,pshead_addr,16, pshead_value);
+             monitor_printf(mon,  "EPROCESS_ActiveProcessLinks : 0x" TARGET_FMT_lx "\n" , eprocess_actproclink_addr); 
+             monitor_printf(mon,  "-----------------Process List-----------------\n");
+             monitor_printf(mon,  "0x" TARGET_FMT_lx" " , imagefilename);
+             my_memory_dump_printc(mon, imagefilename);
+             //snprintf(process_name,16,"%" PRIu64, imagefilename_value);
+             //monitor_printf(mon,  "  %s\n",process_name);
+             monitor_printf(mon,  "   ");
+             monitor_printf(mon,  "PID:%*" PRId64"   ",4,pid_value);
+             monitor_printf(mon,  "PPID:%*" PRId64"   ",4,ppid_value);
+             monitor_printf(mon,  "Handle table: 0x" TARGET_FMT_lx " \n" ,handle_table_addr);
+
+             while(my_memory_dump(eprocess_actproclink_addr) != pshead_value)
+             {
+                    eprocess_next_actproclink_addr = my_memory_dump(eprocess_actproclink_addr) ; 
+                    //monitor_printf(mon,  "EPROCESS_ActiveProcessLinks : 0x" TARGET_FMT_lx "\n" ,(target_ulong) eprocess_next_actproclink_addr);
+                    pcb_addr = eprocess_next_actproclink_addr - PCB;
+                    imagefilename  = pcb_addr + ImageFileName;
+                    ppid_addr = pcb_addr + PPID; 
+                    ppid_value = my_memory_dump_printd(ppid_addr);
+                    pid_addr = pcb_addr + PID; 
+                    pid_value = my_memory_dump_printd(pid_addr);
+                    handle_table_addr = my_memory_dump(pcb_addr + handle_table);
+                    //get the address of entry
+                    table_code = my_memory_dump(handle_table_addr);
+                    handle_entry = table_code & ~7;
+                    if(pid_value ==0)
+                        break; //break for last process
+
+                    monitor_printf(mon,  "0x" TARGET_FMT_lx" " , imagefilename);
+                    my_memory_dump_printc(mon, imagefilename);
+                    monitor_printf(mon,  "   ");
+                    monitor_printf(mon,  "PID:%*" PRId64"   ",4,pid_value);
+                    monitor_printf(mon,  "PPID:%*" PRId64"   ",4,ppid_value);
+                    monitor_printf(mon,  "Table: 0x" TARGET_FMT_lx " \n" ,handle_entry);
+                    
+                    if((table_code & 7) == 0){
+                        // level 1 handle table
+                        // win7 x64 -> KERNEL_HANDLE_MASK = 0xFFFFFFFF80000000
+                        int i = 0;
+                        while(i < 256){ //256 entries
+                            target_ulong object_addr = (my_memory_dump(handle_entry)&~0x7)|0x8000000000000000;
+                            target_ulong object_type = object_addr+0x18;
+                            target_ulong object_body = object_addr+0x30;
+                            if((my_memory_dump(object_type)&0xffff) == 0x1c){
+                                // monitor_printf(mon,  "Object_body: 0x" TARGET_FMT_lx " \n" ,object_addr+0x30);
+                                int length = (int)(my_memory_dump(object_body+0x58)&0xff);
+                                
+                                //At 0x58: +0x000 length  / +0x008 buffer
+                                if(length != 0){
+                                    monitor_printf(mon,  "   ");
+                                    monitor_printf(mon,  "length: %d   ", length);
+                                    memory_dump_string(mon, my_memory_dump(object_body+0x60), length);
+                                    // monitor_printf(mon,  "%s\n",get_string(my_memory_dump(object_body+0x60),length) );
+                                    monitor_printf(mon,  "\n");                                    
+                                }
+                            }
+                            handle_entry += 0x10;
+                            i++;
+                        }
+                        
+                    }
+                    else if((table_code & 7) == 1){
+                        int i = 1;
+                        while(my_memory_dump(handle_entry)!=0){
+                            monitor_printf(mon,  "Table num: %d \n",i);
+                            target_ulong lv2_handle_entry = my_memory_dump(handle_entry);
+                            int j = 0;
+                            while(j < 256){ //256 entries
+                                target_ulong object_addr = (my_memory_dump(lv2_handle_entry)&~0x7)|0x8000000000000000;
+                                target_ulong object_type = object_addr+0x18;
+                                target_ulong object_body = object_addr+0x30;
+                                if((my_memory_dump(object_type)&0xffff) == 0x1c){
+                                    // monitor_printf(mon,  "Object_body: 0x" TARGET_FMT_lx " \n" ,object_addr+0x30);
+                                    int length = (int)(my_memory_dump(object_body+0x58)&0xff);
+                                    
+                                    //At 0x58: +0x000 length  / +0x008 buffer
+                                    if(length != 0){
+                                        monitor_printf(mon,  "   ");
+                                        monitor_printf(mon,  "length: %d   ", length);
+                                        memory_dump_string(mon, my_memory_dump(object_body+0x60), length);    
+                                        monitor_printf(mon,  "\n");                                    
+                                    }
+                                }
+                                lv2_handle_entry += 0x10;
+                                j++;
+                            }
+
+                            i++;
+                            handle_entry += 0x8;
+                        }
+                        
+
+                    }
+                    else
+                        monitor_printf(mon,  "Multi-level \n");
+                    // monitor_printf(mon,  "tnum:%*" PRId64"   \n",4,my_memory_dump_printd(handle_table_addr & 7));
+
+                    process_num++;
+                    eprocess_actproclink_addr =  eprocess_next_actproclink_addr ;
+             }
+                monitor_printf(mon, "-----------------------------------------------\n");
+                monitor_printf(mon,  "Total : %d processes \n",process_num);
+             }
+}
+
+static void getcr3(Monitor *mon)
+{
+    target_ulong KDBG_addr;
+    target_ulong pshead_addr ; 
+    target_ulong eprocess_actproclink_addr; 
+    target_ulong eprocess_next_actproclink_addr ;
+    target_ulong pcb_addr;//eprocess_head_addr = pcb
+    target_ulong imagefilename ;
+    target_ulong pid_addr , pid_value ;
+    target_ulong pshead_value; 
+    target_ulong cr3_value;
+    target_ulong cr3_addr;  
+    
+    CPUArchState *env;
+    
+    KDBG_addr = findKDBG();
+
+    if(KDBG_addr + KDBG_offset == 0xfffff80004000000)
+    {
+             monitor_printf(mon,  "Could not found KDBG address.\n");
+    }else{           
+             pshead_addr  = KDBG_addr + PsActiveProcessHead;
+             pshead_value = my_memory_dump(pshead_addr); 
+               
+             //first process 
+             eprocess_actproclink_addr = my_memory_dump(pshead_value) ; //pshead_value 's value = eprocess_actkink_addr
+             pcb_addr = eprocess_actproclink_addr - PCB;
+             cr3_addr = pcb_addr + CR3;
+             cr3_value = my_memory_dump(cr3_addr) ; 
+             imagefilename = pcb_addr + ImageFileName;
+             pid_addr = pcb_addr + PID; 
+             pid_value = my_memory_dump_printd(pid_addr);
+
+             monitor_printf(mon,  "-----------------Process CR3-----------------\n");
+             monitor_printf(mon,  "ProcessName:");
+             my_memory_dump_printc(mon, imagefilename);
+             monitor_printf(mon,  "PID:%*" PRId64"   ",4,pid_value);
+             monitor_printf(mon,  "CR3=0x" TARGET_FMT_lx "\n", cr3_value);
+
+             while(my_memory_dump(eprocess_actproclink_addr) != pshead_value)
+             {
+                    eprocess_next_actproclink_addr = my_memory_dump(eprocess_actproclink_addr) ; 
+                    pcb_addr = eprocess_next_actproclink_addr - PCB;
+                    imagefilename  = pcb_addr + ImageFileName;
+                    cr3_addr = pcb_addr + CR3;
+                    cr3_value = my_memory_dump(cr3_addr) ; 
+                    pid_addr = pcb_addr +PID; 
+                    pid_value = my_memory_dump_printd(pid_addr);
+
+                    if(pid_value ==0)
+                        break; //break for last process
+             
+                   monitor_printf(mon,  "ProcessName:");
+                   my_memory_dump_printc(mon, imagefilename);
+                   monitor_printf(mon,  "PID:%*" PRId64"   ",4,pid_value);
+                   monitor_printf(mon,  "CR3=0x" TARGET_FMT_lx"\n", cr3_value);
+              
+                   eprocess_actproclink_addr =  eprocess_next_actproclink_addr ;
+             }
+                monitor_printf(mon, "---------------------------------------------\n");
+                env = mon_get_cpu();
+                monitor_printf(mon,  "Current vcpu CR3 = 0x" TARGET_FMT_lx" (physical addr)\n", env->cr[3]); 
+             }
+}
+
+// find paged_pool -> find files -> traverse and find the object
+// FFFFF8a000000000    FFFFF8bFFFFFFFFF   128GB   Paged Pool Area
+static void pool_files(Monitor *mon)
+{
+  // target_ulong file_tag = 0x00000000e56c6946; 
+  target_ulong start_addr = 0xFFFFFa8000D00004;
+  //0xFFFFF8a000500000
+  //0xFFFFF8a002000000
+  target_ulong end_addr = 0xFFFFFa8003000004;
+  // target_ulong end_addr = 0xFFFFF8bFFFFFFFFF; 0xFFFFF8a000D20000
+  // target_ulong file_tag = 0x00000000e56c6946;
+  // target_ulong last_addr;
+
+   while(start_addr < end_addr){
+        
+        // if(my_memory_dump(start_addr) == file_tag){
+            monitor_printf(mon,  "Dump : 0x"TARGET_FMT_lx "\n" ,start_addr);
+            my_memory_dump_printc(mon, start_addr);
+            // break;
+        // }
+         start_addr += pool_offset;
+   }
+    monitor_printf(mon, "Traverse done!\n");  
+}
+
+static void hmp_pslist(Monitor *mon, const QDict *qdict)
+{
+    const char *arg = qdict_get_try_str(qdict, "command");
+    target_ulong KDBG_addr;
+    
+    if(arg){
+              if(strcmp(arg, "-h") == 0){
+                      monitor_printf(mon,  "List the active process in guest Windows OS. Usage: pslist [-h]\n");  
+             }else{
+                      monitor_printf(mon,  "Unknown command. Usage: pslist [-h]\n");  
+             }
+    }else{
+             KDBG_addr = findKDBG();
+             PSlist(mon, KDBG_addr);
+    }
+}
+
+
+static void hmp_pool_files(Monitor *mon, const QDict *qdict)
+{
+    const char *arg = qdict_get_try_str(qdict, "command");
+    if(arg){
+              if(strcmp(arg, "-h") == 0)
+                      monitor_printf(mon,  "List the active process cr3 value in guest Windows OS.\n");    
+              else 
+                      monitor_printf(mon,  "Unknown command. Usage: getcr3 [-h]\n");  
+    }else{
+             pool_files(mon);
+    } 
+}
+
+static void hmp_getcr3(Monitor *mon, const QDict *qdict)
+{
+    const char *arg = qdict_get_try_str(qdict, "command");
+    if(arg){
+              if(strcmp(arg, "-h") == 0)
+                      monitor_printf(mon,  "List the files in guest Windows OS.\n");    
+              else 
+                      monitor_printf(mon,  "Unknown command. Usage: pool_files [-h]\n");  
+    }else{
+             getcr3(mon);
+    } 
+}
 static void hmp_memory_dump(Monitor *mon, const QDict *qdict)
 {
     int count = qdict_get_int(qdict, "count");
@@ -1907,12 +1345,7 @@ static void hmp_physical_memory_dump(Monitor *mon, const QDict *qdict)
     int count = qdict_get_int(qdict, "count");
     int format = qdict_get_int(qdict, "format");
     int size = qdict_get_int(qdict, "size");
+    target_long addr = qdict_get_int(qdict, "addr");
-    hwaddr addr = qdict_get_int(qdict, "addr");
 
     memory_dump(mon, count, format, size, addr, 1);
 }
--- /dev/null
+++ b/name2sector_singl.sh
@@ -1,14 +0,0 @@
+#!/bin/zsh
+# $1 = argv -> filename 
+
+entry=$(ifind -n "$1" win7.img -o 206848)
+
+info=$(istat -o 206848 win7.img $entry) 
+
+cluster=$(sed -n '/init_size/{n;p}' <<<"$info")
+
+clusters=($cluster)
+
+let sector="${clusters[0]}*8+206848"
+
+echo $sector
--- /dev/null
+++ b/plugin.c
@@ -1,66 +0,0 @@
+#include "config.h"
+#include <dlfcn.h>
+#include <assert.h>
+#include "sysemu/sysemu.h"
+#include "plugin.h"
+
+
+
+plugin_interface_t *plugin = NULL;
+static void *plugin_handle = NULL;
+static char cur_plugin_path[100] = "";
+
+void do_load_plugin(const char *plugin_path)
+{
+    printf("Start loading plugin \n");
+    plugin_interface_t *(*init_plugin) (void);
+    char *error;
+
+    //allow multiple plugins?
+    // if(cur_plugin_path[0]){
+    //     term_printf("%s has already been loaded! \n", plugin_path);
+    //   return;
+    // }
+
+    plugin_handle = dlopen(plugin_path, RTLD_NOW | RTLD_GLOBAL);
+    if(NULL == plugin_handle) {
+    // plugin_handle = dlopen(plugin_path, RTLD_NOW);
+    // if (NULL == plugin_handle) {
+        printf("%s\n", dlerror());
+        return;
+    }
+
+    dlerror();
+
+    init_plugin = dlsym(plugin_handle, "init_plugin");
+    if ((error = dlerror()) != NULL) {
+        fprintf(stderr, "%s\n", error);
+        dlclose(plugin_handle);
+        plugin_handle = NULL;
+        return;
+    }
+
+    plugin = init_plugin();
+    if (NULL == plugin) {
+        printf("fail to initialize the plugin!\n");
+        dlclose(plugin_handle);
+        plugin_handle = NULL;
+        return;
+    }
+
+    strncpy(cur_plugin_path, plugin_path, 100);
+    printf("%s is loaded successfully!\n", plugin_path);
+}
+
+void do_unload_plugin(void)
+{
+    if (cur_plugin_path[0]) {
+        // plugin->plugin_cleanup();
+        dlclose(plugin_handle);
+        plugin_handle = NULL;
+        plugin = NULL;
+
+        printf("plugin unloaded!\n");
+        cur_plugin_path[0] = 0;
+    }
+}
diff --git a/plugin.h b/plugin.h
deleted file mode 100644
index 3502e32..0000000
--- /dev/null
+++ b/plugin.h
@@ -1,26 +0,0 @@
+
+//structure for plugin
+typedef struct plugin_interface_t {
+
+    // array of terminal commands
+    void *term_cmds;
+    void *info_cmds;
+    long long cr3_addr;
+    int taint_record_size;
+    void (*reset_plugin)(const char *property);
+    void (*set_plugin)(const char *property, const char *value );
+    void (*toggle_plugin)(const char *property);
+
+    // void (*taint_disk) (int size, int64_t sect_num, int flag,uint32_t paddr);
+    void (*nic_recv) (const uint8_t *buf, size_t size);
+    void (*nic_send) (const uint8_t *buf, size_t size);
+    void (*blk_write) (uint64_t sector_num, uint64_t base, uint64_t len);
+    void (*blk_read) (uint64_t sector_num, uint64_t base, uint64_t len);
+
+    void (*test) (void);
+
+} plugin_interface_t;
+extern plugin_interface_t *plugin;
+
+void do_load_plugin(const char *plugin_path);
+void do_unload_plugin(void);
diff --git a/plugins/Makefile b/plugins/Makefile
deleted file mode 100644
index 14aba2f..0000000
--- /dev/null
+++ b/plugins/Makefile
@@ -1,21 +0,0 @@
+# include ../config-host.mak
+
+# DEFINES=-I. -I.. 
+
+PLUGIN = plugin.so
+
+all: main.c 
+ gcc -shared -o $(PLUGIN) -fPIC main.c
+ 
+# %.o: %.c 
+#  gcc  -c -o $@ $<
+
+# # %.o: %.cpp
+# #  g++ $(DEFINES) -c -o $@ $<
+
+# %.so: main.o 
+#  g++  $^ -o -c $@ 
+
+clean:
+ rm -f *.o *.so *~ $(PLUGIN)
+
diff --git a/plugins/main.c b/plugins/main.c
--- /dev/null
+++ b/plugins/main.c
@@ -1,648 +0,0 @@
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <inttypes.h>
+#include <time.h>
+// #include "../config.h"
+#include "main.h"
+#include "../plugin.h"
+
+static plugin_interface_t my_interface;
+FILE *my_log;
+
+typedef enum { false = 0, true = !false } bool;
+int PDU_bytes = 128;
+
+int target_s_port = -1;
+int target_d_port = -1;
+
+char* target_s_ip = "NOT_SET";
+char* target_d_ip = "NOT_SET";
+
+int target_protocol_number = -1;
+
+bool enable_print_packet = false;
+bool enable_log = false;
+bool enable_pcap_log = false;
+
+bool enable_traceblk = false;
+bool enable_print_blkio = false;
+bool first_file = 1;
+int count = 0;
+
+uint64_t sector_number = 0;
+char* target_file_name = "NOT_SET";
+
+typedef struct node
+{
+  int data;
+  char fname[50];
+  struct node* next;
+} NODES;
+
+//NODES* list;
+static NODES *list = NULL;
+
+typedef struct mon_cmd_t {
+  const char *name;
+  const char *args_type;
+  const char *params;
+  const char *help;
+  union {
+    void (*cmd);
+  } mhandler;
+} mon_cmd_t;
+
+static void temp_function()
+{
+  printf("nic_target_port\n");
+}
+
+static void get_sectornum(char* filename);
+static void saveFile(NODES* list, char* fname);
+static void print_lists(NODES *node);
+
+
+static mon_cmd_t my_term_cmds[] = {
+  {
+    .name       = "temp_function",
+    .args_type  = "",
+    .params     = "",
+    .help       = "temp_function",
+    .mhandler.cmd = temp_function
+  },
+  {NULL, NULL},
+};
+
+static void test()
+{
+  printf("test\n");
+}
+
+static void set_plugin(const char *property, const char *value ) {
+  char* temp_string;
+  temp_string = "target_s_port";
+  if (strcmp(property, temp_string) == 0) {
+    target_s_port = atoi(value);
+    printf("setting target source port: %d\n", target_s_port);
+    return;
+  }
+  temp_string = "target_d_port";
+  if (strcmp(property, temp_string) == 0) {
+    target_d_port = atoi(value);
+    printf("setting target destination port: %d\n", target_d_port);
+    return;
+  }
+  temp_string = "target_s_ip";
+  if (strcmp(property, temp_string) == 0) {
+    target_s_ip = strdup(value);
+    printf("setting target source ip: %s\n", target_s_ip);
+    return;
+  }
+  temp_string = "target_d_ip";
+  if (strcmp(property, temp_string) == 0) {
+    target_d_ip = strdup(value);
+    printf("setting target destination ip: %s\n", target_d_ip);
+    return;
+  }
+  temp_string = "PDU_bytes";
+  if (strcmp(property, temp_string) == 0) {
+    PDU_bytes = atoi(value);
+    printf("setting PDU bytes: %d\n", PDU_bytes);
+    return;
+  }
+
+  temp_string = "target_protocol_number";
+  if (strcmp(property, temp_string) == 0) {
+    target_protocol_number = atoi(value);
+    printf("setting target protocol number: %d\n", target_protocol_number);
+    if (target_protocol_number == 6) {
+      printf("Protocol: 6(tcp)\n");
+    }
+    else if (target_protocol_number == 17) {
+      printf("Protocol: 17(udp)\n");
+    }
+    else if (target_protocol_number == 1) {
+      printf("Protocol: 128(icmp)\n");
+    }
+    else {
+      printf("Protocol number:%d\n", target_protocol_number);
+    }
+    return;
+  }
+
+  temp_string = "target_file_name";
+  if (strcmp(property, temp_string) == 0) {
+    target_file_name = strdup(value);
+    printf("setting target file name: %s\n", target_file_name);
+    char * file;
+    file = strdup(value);
+    //if(first_file == 1)
+
+    saveFile(list, file);
+    return;
+  }
+  temp_string = "file_list";
+  if (strcmp(property, temp_string) == 0) {
+    printf("Print current file list: \n");
+    print_lists(list);
+  }
+}
+static void reset_plugin(const char *property) {
+  char* temp_string;
+  temp_string = "target_s_port";
+  if (strcmp(property, temp_string) == 0) {
+    printf("resetting target source port\n");
+    target_s_port = -1;
+    return;
+  }
+  temp_string = "target_d_port";
+  if (strcmp(property, temp_string) == 0) {
+    printf("resetting target destination port\n");
+    target_d_port = -1;
+    return;
+  }
+  temp_string = "target_s_ip";
+  if (strcmp(property, temp_string) == 0) {
+    printf("resetting target source ip\n");
+    target_s_ip = "NOT_SET";
+    return;
+  }
+  temp_string = "target_d_ip";
+  if (strcmp(property, temp_string) == 0) {
+    printf("resetting target destination ip\n");
+    target_d_ip = "NOT_SET";
+    return;
+  }
+  temp_string = "PDU_bytes";
+  if (strcmp(property, temp_string) == 0) {
+    printf("resetting PDU bytes (128)\n");
+    PDU_bytes = 128;
+    return;
+  }
+  temp_string = "target_protocol_number";
+  if (strcmp(property, temp_string) == 0) {
+    printf("resetting target protocol number\n");
+    target_protocol_number = -1;
+    return;
+  }
+}
+static void toggle_plugin(const char *property) {
+  char* temp_string;
+  temp_string = "enable_print_packet";
+  if (strcmp(property, temp_string) == 0) {
+    enable_print_packet = !enable_print_packet;
+    printf("toggle enable_print_packet: %d\n", enable_print_packet);
+    return;
+  }
+  temp_string = "enable_log";
+  if (strcmp(property, temp_string) == 0) {
+    enable_log = !enable_log;
+    printf("toggle enable_log: %d\n", enable_log);
+    return;
+  }
+  temp_string = "enable_pcap_log";
+  if (strcmp(property, temp_string) == 0) {
+    enable_pcap_log = !enable_pcap_log;
+    printf("toggle enable_pcap_log: %d\n", enable_pcap_log);
+    return;
+  }
+  temp_string = "enable_traceblk";
+  if (strcmp(property, temp_string) == 0) {
+    enable_traceblk = !enable_traceblk;
+    printf(" enable_traceblk: %d\n", enable_traceblk );
+    return;
+
+  }
+  temp_string = "enable_print_blkio";
+  if (strcmp(property, temp_string) == 0) {
+    enable_print_blkio = !enable_print_blkio;
+    printf("enable_print_blkio\n");
+    return;
+  }
+
+
+}
+
+static void log_packet_pcap(const uint8_t *buf, size_t size) {
+  // return;
+  FILE * fp;
+
+  // time_t rawtime;
+  // struct tm * timeinfo;
+  // time ( &rawtime );
+  // timeinfo = localtime ( &rawtime );
+
+  fp = fopen ("packet_log.pcap", "ab"); //use time
+
+  struct timeval tv;
+  unsigned int timestamp;
+  gettimeofday(&tv, NULL);
+  timestamp = tv.tv_sec;
+  fwrite( &timestamp, sizeof( timestamp ), 1, fp );
+
+  timestamp = tv.tv_usec;
+  fwrite( &timestamp, sizeof( timestamp ), 1, fp );
+
+  // fwrite( &timestamp, sizeof( timestamp ), 1, fp );
+
+  int Caplen;
+  if (size <= PDU_bytes) {
+    Caplen = size + 4;//test for wireshark process name
+    fwrite( &Caplen, sizeof( Caplen ), 1, fp );
+    fwrite( &Caplen, sizeof( Caplen ), 1, fp );
+  }
+  else {
+    int len = size;
+    Caplen = PDU_bytes + 4;//test for wireshark process name
+    fwrite( &Caplen, sizeof( Caplen ), 1, fp );
+    fwrite( &len, sizeof( len ), 1, fp );
+  }
+  int i = 0;
+  char content;
+  for (i = 0; i < Caplen - 4; i++) {
+
+    content = *(buf + i);
+    fwrite( &content, sizeof( content ), 1, fp );
+
+  }
+  //wiret WORM for wireshark process name test
+  int j;
+  j = 0x4D524F57;
+  fwrite( &j, sizeof( j ), 1, fp );
+
+  chmod("packet_log.pcap", 0777);
+  fclose(fp);
+}
+static void log_packet_readable(const uint8_t *buf, size_t size) {
+  FILE * fp;
+
+  time_t rawtime;
+  struct tm * timeinfo;
+  time ( &rawtime );
+  timeinfo = localtime ( &rawtime );
+
+  fp = fopen ("packet_log", "a"); //use time
+
+  fprintf(fp, "[packet received]%s\n", asctime(timeinfo));
+  fprintf(fp, "Source IP:%d.%d.%d.%d\n", *(buf + 26), *(buf + 27), *(buf + 28), *(buf + 29));
+  fprintf(fp, "Source Port:%d\n", 256 * (*(buf + 34)) + * (buf + 35));
+  fprintf(fp, "Destination IP:%d.%d.%d.%d\n", *(buf + 30), *(buf + 31), *(buf + 32), *(buf + 33));
+  fprintf(fp, "Destination Port:%d\n", 256 * (*(buf + 36)) + * (buf + 37));
+  if (*(buf + 23) == 6)
+    fprintf(fp, "Protocol: 6(tcp)\n");
+  else if (*(buf + 23) == 17)
+    fprintf(fp, "Protocol: 17(udp)\n");
+  else if (*(buf + 23) == 1)
+    fprintf(fp, "Protocol: 128(icmp)\n");
+  else
+    fprintf(fp, "Protocol number:%d\n", *(buf + 23));
+  fprintf(fp, "pdu: ");
+  int i;
+  for (i = 0; i < size; i++) {
+    if (i % 2 == 0)
+      fprintf(fp, " ");
+    fprintf(fp, "%02x", *(buf + i));
+  }
+  fprintf(fp, "     -end\r\n");
+  fprintf(fp, "---------------------------------------\r\n");
+  chmod("packet_log", 0777);
+  fclose(fp);
+}
+
+static void print_packet(const uint8_t *buf, size_t size) {
+  time_t rawtime;
+  struct tm * timeinfo;
+  time ( &rawtime );
+  timeinfo = localtime ( &rawtime );
+  printf("[packet received]%s\n", asctime(timeinfo));
+  printf("Source IP:%d.%d.%d.%d\n", *(buf + 26), *(buf + 27), *(buf + 28), *(buf + 29));
+  printf("Source Port:%d\n", 256 * (*(buf + 34)) + * (buf + 35));
+  printf("Destination IP:%d.%d.%d.%d\n", *(buf + 30), *(buf + 31), *(buf + 32), *(buf + 33));
+  printf("Destination Port:%d\n", 256 * (*(buf + 36)) + * (buf + 37));
+  if (*(buf + 23) == 6)
+    printf("Protocol: tcp\n");
+  else if (*(buf + 23) == 17)
+    printf("Protocol: udp\n");
+  else if (*(buf + 23) == 1)
+    printf("Protocol: icmp\n");
+  else
+    printf("Protocol number:%d\n", *(buf + 23));
+
+  printf("pdu: ");
+  int i;
+  for (i = 0; i < size; i++) {
+    printf("%02x ", *(buf + i));
+  }
+  printf("\n---------------------------------------\n");
+}
+
+static void get_logged(const uint8_t *buf, size_t size) {
+  if (enable_print_packet) {
+    print_packet(buf, size);
+  }
+  if (enable_log) {
+    log_packet_readable(buf, size);
+  }
+  if (enable_pcap_log) {
+    log_packet_pcap(buf, size);
+  }
+}
+
+static void get_packet(const uint8_t *buf, size_t size, int mode) {
+  if (
+    !enable_print_packet &&
+    !enable_log &&
+    !enable_pcap_log
+  )
+  {
+    return;
+  }
+  int s_port = 256 * (*(buf + 34)) + *(buf + 35);
+  int d_port = 256 * (*(buf + 36)) + *(buf + 37);
+
+  char s_ip[100];
+  char d_ip[100];
+  sprintf(s_ip, "%d.%d.%d.%d", *(buf + 26), *(buf + 27), *(buf + 28), *(buf + 29));
+  sprintf(d_ip, "%d.%d.%d.%d", *(buf + 30), *(buf + 31), *(buf + 32), *(buf + 33));
+  char* target_ip_not_set = "NOT_SET";
+
+
+  int protocol_number = *(buf + 23);
+
+  if ((
+        (
+          target_s_port != -1 &&
+          target_s_port != s_port
+        ) || (
+          target_d_port != -1 &&
+          target_d_port != d_port
+        )
+      )
+      || (
+        (
+          strcmp(target_s_ip, target_ip_not_set) != 0 &&
+          strcmp(target_s_ip, s_ip) != 0
+        ) || (
+          strcmp(target_d_ip, target_ip_not_set) != 0 &&
+          strcmp(target_d_ip, d_ip) != 0
+        )
+      )
+      || (
+        target_protocol_number != -1 &&
+        protocol_number != target_protocol_number
+      )
+     ) {
+    return;
+  }
+  get_logged(buf, size);
+}
+
+static void get_sectornum(char* filename){
+  char buf[30]; 
+  char buff[30]; 
+
+  FILE *fp;
+  //printf("%s\n","hi" );
+  // bash ./fname2sector.sh filename
+  char* bash = "bash ../fname2sector_singl.sh ";  
+  char* file = filename;
+
+  char *s = malloc(strlen(bash) + strlen(file) + 1);
+  strcpy(s, bash);
+  strcat(s, file);
+
+  if ((fp = popen(s, "r")) == NULL) {
+    printf("popen() error!\n");
+    exit(1);
+  }
+  // run the shell script with popen
+  fgets(buf, sizeof buf, fp);
+  // fgets the first sector info
+  //printf("%s", buf);
+  pclose(fp);
+  free(s);
+
+
+  if (atoi(buf) == -1000)
+  {
+    char* c  ="../../fname2sector_res ../../win7_test.img";
+    char* s = malloc(strlen(c)+1);
+    strcpy(s,c);
+    strcpy(s,file);
+    if ((fp = popen(s, "r")) == NULL) {  
+      printf("popen() error!\n");  
+      exit(1);
+    }
+    fgets(buff,sizeof buff, fp);
+    pclose(fp);
+    free(s);
+  }
+  int sector;
+  if(atoi(buf) == -1000)
+    sector = atoi(buff);
+  else
+    sector = atoi(buf);
+  
+
+  sector_number = (uint64_t) sector;
+  printf("get sector num:%"PRIu64"\n", sector_number);
+  //get
+}
+
+
+static void print_blockio (uint64_t sector_num, uint64_t base, uint64_t len, int dir, char* fname) {
+  time_t rawtime;
+  struct tm * timeinfo;
+  time ( &rawtime );
+  timeinfo = localtime ( &rawtime );
+  printf("\n");
+  printf("[io time]%s\n", asctime(timeinfo));
+  printf("filename: %s\n", fname);
+  printf("sector number: %"PRIu64"\n", sector_num);
+
+  // if(strstr(fname,"txt"))
+  //   printf("Process: notepad.exe" );
+  // else
+  //   printf("Process: mspaint.exe");
+  printf("\nIO buffer: \n");
+  printf("  base: %"PRIu64"\n", base);
+  printf("  length: %"PRIu64"\n", len);
+  if(dir == 1)
+    printf("IO Write\n");
+  else if (dir == 0)
+    printf("IO Read\n");
+
+FILE* log = fopen("../IO_log.log", "a");
+  fprintf(log,"\n");
+  fprintf(log,"[io time]%s\n", asctime(timeinfo));
+  fprintf(log,"filename: %s\n",fname);
+  fprintf(log,"sector number: %"PRIu64"\n", sector_num);
+  fprintf(log,"Process: notepad.exe" );
+  fprintf(log,"\nIO buffer: \n");
+  fprintf(log,"  base: %"PRIu64"\n", base);
+  fprintf(log,"  length: %"PRIu64"\n", len);
+  if(dir == 1)
+    fprintf(log,"IO Write\n");
+  else if(dir == 0)
+    fprintf(log,"IO Read\n");
+  fprintf(log, "=====================================\n");
+fclose(log);
+
+}
+
+
+static void log_blkio(uint64_t sector_num, uint64_t base, uint64_t len, int dir, char* fname) {
+  //if(enable_print_blkio)
+// printf("say\n");
+  print_blockio(sector_num, base, len, dir, fname);
+
+}
+
+
+
+static void get_blockio(uint64_t sector_num, uint64_t base, uint64_t len, int dir) {
+//printf("hi2\n");
+  // if((sector_number == 0) || (sector_number != sector_num))
+  // {
+  //  // printf("Nothing!\n");
+  //   return;
+  // }
+  // log_blkio(sector_num, base, len, dir);
+  NODES* tmp = list;
+
+  while (tmp != NULL)
+  {
+    if ((sector_num == 0))
+    {
+      return;
+    }
+
+    if (sector_num == tmp->data)
+      log_blkio(sector_num, base, len, dir, tmp->fname);
+    
+    tmp = tmp->next;
+  }
+}
+
+  
+
+
+
+
+
+static void do_nic_receive(const uint8_t *buf, size_t size) {
+  get_packet(buf, size, 0);
+}
+
+static void do_nic_send(const uint8_t *buf, size_t size) {
+  get_packet(buf, size, 1);
+}
+
+static void do_blk_write(uint64_t sector_num, uint64_t base, uint64_t len) {
+  get_blockio(sector_num, base, len, 1);
+  
+}
+
+static void do_blk_read(uint64_t sector_num, uint64_t base, uint64_t len) {
+  get_blockio(sector_num, base, len, 0);\
+}
+
+static void insertNode(NODES *node, char fname[], int data)
+{
+  NODES *newNode = (NODES *)malloc(sizeof(NODES));
+  newNode->data = data;
+  strcpy(newNode->fname, fname);
+  newNode->next = node->next;
+  node->next = newNode;
+
+}
+
+static void print_lists(NODES *node)
+{
+  NODES* n = node;
+
+  while (n != NULL)
+  {
+    printf("%s: %d\n", n->fname, n->data);
+
+    n = n->next;
+  }
+
+}
+
+static void freeList(NODES* head)
+{
+  NODES* tmp;
+
+  while (head != NULL)
+  {
+    tmp = head;
+    head = head->next;
+    free(tmp);
+  }
+}
+
+static void saveFile(NODES* list, char* fname)
+{
+  get_sectornum(fname);
+  int sector = (int) sector_number;
+  if (first_file) {
+    if (sector != 0) {
+      //*list = malloc(sizeof(NODES));
+      strcpy(list->fname, fname);
+      list->data = sector;
+      list->next = NULL;
+      first_file =  0;
+    }
+  } else {
+
+    insertNode(list, fname, sector);
+    count ++;
+  }
+
+}
+
+
+static void create_logfile(void) {
+  remove("packet_log.pcap");
+  FILE * fp;
+  long int header;
+  fp = fopen ("packet_log.pcap", "a"); //use time
+  // const char *header = "d4c3 b2a1 0200 0400 0000 0000 0000 0000\nffff 0000 0100 0000 ";
+  header = 0x00040002a1b2c3d4;
+  fwrite( &header, sizeof( header ), 1, fp );
+  header = 0x0000000000000000;
+  fwrite( &header, sizeof( header ), 1, fp );
+  header = 0x000000010000ffff;
+  fwrite( &header, sizeof( header ), 1, fp );
+
+  fclose(fp);
+}
+
+plugin_interface_t * init_plugin()
+{
+  if (!(my_log = fopen("plugin.log", "a"))) {
+    fprintf(stderr, "cannot create plugin.log\n");
+    return NULL;
+  }
+  create_logfile();
+  //NODES *list = (NODES *)malloc(sizeof(NODES));
+  //static NODES *list = NULL;
+  if (list == NULL)
+    list = (NODES *)malloc(sizeof(NODES));
+  my_interface.nic_send = do_nic_send;
+  my_interface.nic_recv = do_nic_receive;
+  my_interface.blk_write = do_blk_write;
+  my_interface.blk_read = do_blk_read;
+  // my_interface.term_cmds = my_term_cmds;
+
+  my_interface.test = test;
+  my_interface.set_plugin = set_plugin;
+  my_interface.toggle_plugin = toggle_plugin;
+  my_interface.reset_plugin = reset_plugin;
+  return &my_interface;
+}
+
+
diff --git a/plugins/main.h b/plugins/main.h
deleted file mode 100644
index e69de29..0000000
deleted file mode 100644
index e5a6621..0000000
--- /dev/null
+++ b/profile.h
@@ -1,15 +0,0 @@
+/*The following magic number is for Windows7 SP1 x64 version.
+    You can modify them for other Windows OS version.
+    If you would like to find these magic numbers for a specified Windows,
+    use Windbg in guest OS or dump whole guest memory into a file and 
+    use Volatility framework to analysis it.*/
+#define PsActiveProcessHead 0x50
+#define PCB 0x188
+#define PID  0x180
+#define ImageFileName 0x2e0
+#define CR3 0x28
+#define PPID 0x290
+#define PEB 0x338
+#define LDR 0x18
+#define CreateTime 0x168
+#define KDBG_offset 0x10
--- a/qemu-options.hx
+++ b/qemu-options.hx
@@ -6,7 +6,6 @@ HXCOMM construct option structures, enums and help message for specified
 HXCOMM architectures.
 HXCOMM HXCOMM can be used for comments, discarded from both texi and C
 
+DEFHEADING(TEST)
 DEFHEADING(Standard options:)
 STEXI
 @table @option
@@ -3029,14 +3028,6 @@ STEXI
 Start right away with a saved state (@code{loadvm} in monitor)
 ETEXI
 
+DEF("load-plugin", HAS_ARG, QEMU_OPTION_load_plugin, \
+    "-load-plugin \n" ,QEMU_ARCH_ALL)
+STEXI
+@item -load-plugin @var{file}
+@findex -load-plugin
+do something on loading plugin
+ETEXI
+
 #ifndef _WIN32
 DEF("daemonize", 0, QEMU_OPTION_daemonize, \
     "-daemonize      daemonize QEMU after initializing\n", QEMU_ARCH_ALL)
--- /dev/null
+++ b/static_structs_test.h
@@ -1,18 +0,0 @@
+#define PsActiveProcessHead 0x50
+#define PCB 0x188
+#define PID  0x180
+#define handle_table  0x200
+#define handle_file  0x50
+#define ImageFileName 0x2e0
+#define CR3 0x28
+#define PPID 0x290
+#define PEB 0x338
+#define LDR 0x18
+#define CreateTime 0x168
+#define KDBG_offset 0x10
+#define pool_offset 0x10
+
+void PSlist(Monitor *mon,hwaddr KDBG_addr);
+uint64_t findKDBG(void);
+uint64_t my_memory_dump(hwaddr addr);
+char* f2p_mapping(char* fname);
\ No newline at end of file
deleted file mode 100644
index 1413022..0000000
--- /dev/null
+++ b/test.c
@@ -1,36 +0,0 @@
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+int fname2sector(char* filename){
+  char buf[30];  
+  FILE *fp;
+
+  // bash ./fname2sector.sh filename
+  char* bash = "bash ./fname2sector_singl.sh ";  
+  char* file = filename;
+
+  char *s = malloc(strlen(bash)+strlen(file)+1);
+  strcpy(s, bash);
+  strcat(s, file);
+
+  if ((fp = popen(s, "r")) == NULL) {  
+      printf("popen() error!\n");  
+      exit(1);  
+  }   
+  // run the shell script with popen
+  fgets(buf, sizeof buf, fp);
+  // fgets the first sector info
+  //printf("%s", buf);
+  pclose(fp);  
+  free(s);
+  int sector = atoi(buf);
+  return sector; 
+}
+
+int main(int argc, char *argv[]) {  
+
+  int sector = fname2sector(argv[1]);
+  printf("%d\n", sector);
+  return 0;  
+} 
--- a/vl.c
+++ b/vl.c
@@ -120,8 +120,6 @@ int main(int argc, char **argv)
 #include "qom/object_interfaces.h"
 #include "qapi-event.h"
 
+#include "plugin.h"
+
 #define DEFAULT_RAM_SIZE 128
 
 #define MAX_VIRTIO_CONSOLES 1
@@ -744,7 +742,7 @@ int qemu_timedate_diff(struct tm *tm)
             struct tm tmp = *tm;
             tmp.tm_isdst = -1; /* use timezone to figure it out */
             seconds = mktime(&tmp);
     else
         seconds = mktimegm(tm) + rtc_date_offset;
 
@@ -2503,7 +2501,6 @@ static void qemu_run_machine_init_done_notifiers(void)
     notifier_list_notify(&machine_init_done_notifiers, NULL);
 }
 
+//try debugging for qemu-options here
 static const QEMUOption *lookup_opt(int argc, char **argv,
                                     const char **poptarg, int *poptind)
 {
@@ -2520,7 +2517,7 @@ static const QEMUOption *lookup_opt(int argc, char **argv,
     popt = qemu_options;
     for(;;) {
         if (!popt->name) {
+            error_report("invalid option test");
-            error_report("invalid option");
             exit(1);
         }
         if (!strcmp(popt->name, r + 1))
@@ -2743,7 +2742,6 @@ int main(int argc, char **argv, char **envp){
     int optind;
     const char *optarg;
     const char *loadvm = NULL;
+    const char *load_plugin = NULL;
     MachineClass *machine_class;
     const char *cpu_model;
     const char *vga_model = NULL;
@@ -2830,7 +2828,6 @@ int main(int argc, char **argv, char **envp){
     autostart = 1;
 
     /* first pass of option parsing */
+    printf("Test version\n" );
     optind = 1;
     while (optind < argc) {
         if (argv[optind][0] != '-') {
@@ -3369,9 +3366,6 @@ int main(int argc, char **argv, char **envp){
             case QEMU_OPTION_loadvm:
                 loadvm = optarg;
                 break;
+            case QEMU_OPTION_load_plugin:
+                load_plugin = optarg;
+                break;
             case QEMU_OPTION_full_screen:
                 full_screen = 1;
                 break;
@@ -4322,18 +4316,6 @@ int main(int argc, char **argv, char **envp){
         exit(1);
     }
 
+    //plugin loading
+
+    if(loadvm == NULL && load_plugin)
+        do_load_plugin(load_plugin);
+
+
+    if(!plugin){
+        printf("No plugin loaded\n");
+    }
+    //end plugin implementation
+
+
     /* TODO: once all bus devices are qdevified, this should be done
      * when bus is created by qdev.c */
     qemu_register_reset(qbus_reset_all_fn, sysbus_get_default());
